from openai import OpenAI
from tenacity import retry, stop_after_attempt, wait_random_exponential
from difflib import SequenceMatcher
import config
import os
import json
import base64
import re
import time
from PIL import Image 
from io import BytesIO


def load_openai_key():
    """Load OpenAI API key from a JSON file."""
    with open(config.OPEN_AI_API_KEY, "r") as file:
        data = json.load(file)
        return data.get("openai_api_key")  # Extract key from JSON

@retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(6))
# Generate AI title with redundancy prevention
def provide_AI_title(prompt):
    client = OpenAI(api_key=api_key2)
    used_titles = load_used_titles()  # Load previous titles

    additional_prompt = config.EVENT_NAME

    for _ in range(3):  # Allow up to 3 retries if title is too similar
        response = client.chat.completions.create(
            messages=[
                {'role': 'system', 'content': 'I want you to act as a title generator for clips of combos in Super Smash Brothers Melee that happened at ' + additional_prompt + '. I will provide you the details of the combo and you will provide a fun title. You have a sixty character limit.'}, 
                {'role': 'user', 'content': f'{prompt}'}
            ], 
            model='gpt-3.5-turbo', 
            temperature=0.9, 
            max_tokens=20
        )

        new_title = response.choices[0].message.content.strip()

        if not is_too_similar(new_title, used_titles):
            save_used_title(new_title)  # Save only if it's unique
            return new_title

    print("Warning: Could not generate a completely unique title after 3 attempts.")
    return new_title  # Return last generated title even if similar

def provide_AI_comptitle(prompt):
    client = OpenAI(api_key=api_key2)
    used_titles = load_used_titles()  # Load previous titles

    additional_prompt = config.EVENT_NAME
    last_title = None

    for _ in range(3):  # Allow up to 3 retries if title is too similar
        response = client.chat.completions.create(
            messages=[
                {'role': 'system', 'content': 'I want you to act as a title generator for a compilation of clips from Super Smash Brothers Melee at ' + additional_prompt + '. I will provide you the individual clip titles and you will provide a fun title for the compilation. You have a sixty character limit.'}, 
                {'role': 'user', 'content': f'{prompt}'}
            ], 
            model='gpt-3.5-turbo', 
            temperature=0.9, 
            max_tokens=20
        )

        new_title = response.choices[0].message.content.strip()
        last_title = new_title

        if not is_too_similar(new_title, used_titles):
            save_used_title(new_title)  # Save only if it's unique
            return new_title

    # Fallback if all attempts are too similar
    print("Warning: All generated titles were too similar. Using last generated title.")
    save_used_title(last_title)  # Still save to avoid repeat use
    return last_title

def provide_AI_desc(title):
    client = OpenAI(api_key=api_key2)
    response = client.chat.completions.create(
        messages=[
            {'role': 'system', 'content': 'I would like you to write me a 200 word description for my new Youtube short. I want this description to be packed full of keywords and SEO to help me rank high in my niche and among search results when people search for videos like mine'}, 
            {'role': 'user', 'content': f'The video title is: {title}, My niche is: Super Smash Brothers Melee Clips, My target viewers are: gamers, tournament organizers, eSports fans'}
        ], 
        model='gpt-3.5-turbo', 
        temperature=0.7, 
        max_tokens=270
    )
    description = response.choices[0].message.content.strip()
    return description

def provide_comp_thumbnail(title):
    client = OpenAI(api_key=api_key2)
    additional_prompt = config.EVENT_NAME
    prompt = (
        f"Design a bright and colorful thumbnail for a video game compilation from the event {additional_prompt}. "
        f"The style should be inspired by retro arcade aesthetics, fun and family-friendly, with pixel art or vibrant action elements."
    )
    print(prompt)

    try:
        response = client.images.generate(
            
            model="gpt-image-1",  # Specify the latest model for better quality
            prompt=prompt,
            moderation="low", # Control the content-moderation level for images generated by gpt-image-1. Must be either low for less restrictive filtering or auto (default value).
            n=1,  # Generate only one image
            output_format='jpeg', #Must be one of png, jpeg, or webp
            quality='medium', #high, medium and low are supported
            size="1536x1024"  # Must be one of 1024x1024, 1536x1024 (landscape), 1024x1536 (portrait), or auto (default value) 
        )

        # Extract the image URL
        image_url = response.data[0].url

        # Define the output file path
        image_filename = f"{title.replace(' ', '_').replace('#', '')}.png"
        image_path = os.path.join(config.THUMBNAILS_FOLDER, image_filename)

        # Download and save the image
        import requests
        img_data = requests.get(image_url).content
        with open(image_path, "wb") as img_file:
            img_file.write(img_data)

        print(f"Image saved successfully: {image_path}")
        return image_path

        # Check if file size exceeds 2MB and compress further if needed
        if len(img_data) > 2 * 1024 * 1024:
            from PIL import Image
            from io import BytesIO

            image = Image.open(BytesIO(img_data))
            compressed_path = image_path
            image.save(compressed_path, format='JPEG', quality=85, optimize=True)  # Adjust quality if needed
        else:
            with open(image_path, "wb") as img_file:
                img_file.write(img_data)

        print(f"Image saved successfully: {image_path}")
        return image_path

    except Exception as e:
        print(f"Error generating image: {e}")
        return None

def provide_image(title):
    client = OpenAI(api_key=api_key2)

    with open(config.EVENT_TITLE, 'r') as file:
        event_title=file.read()
    with open(config.VENUE_DESC, 'r') as file:
        venue_desc=file.read()
    
        
    prompt = (
        f"Design a bright and colorful thumbnail for a compilation of clips from the event {event_title} which takes place in a {venue_desc}"
        f"The style should be inspired by retro arcade aesthetics, include items such as floating platforms, dolphins, frogs, gamecube controllers, CRTs, and similar."
    )
    print(prompt)

    title = title.replace("'", "")
    title = title.replace(" ", "_")
    title = title.replace('#', '')
    title = re.sub(r'[\\/*?:"<>|]', "", title).strip()
    title = re.sub(r'[^a-zA-Z0-9._-]', '', title)

    image_filename = f"{title}.png"
    image_path = os.path.join(config.THUMBNAILS_FOLDER, image_filename)

    max_retries = 5
    for attempt in range(1, max_retries + 1):
        try:
            result = client.images.generate(
                model="gpt-image-1",
                prompt=prompt,
                n=1,
                size="1536x1024",
                quality="medium"
            )

            image_base64 = result.data[0].b64_json
            image_bytes = base64.b64decode(image_base64)

            # Load into PIL and save as JPEG, compressed
            image = Image.open(BytesIO(image_bytes)).convert("RGB")  # Convert in case it's RGBA
            buffer = BytesIO()
            image.save(buffer, format="JPEG", quality=85, optimize=True)
            jpeg_bytes = buffer.getvalue()

            # Check size and optionally reduce quality further if >2MB
            if len(jpeg_bytes) > 2 * 1024 * 1024:
                buffer = BytesIO()
                image.save(buffer, format="JPEG", quality=75, optimize=True)
                jpeg_bytes = buffer.getvalue()

            with open(image_path, "wb") as f:
                f.write(jpeg_bytes)

            print(f"Image saved successfully: {image_path}")
            return image_path

        except Exception as e:
            print(f"[Attempt {attempt}] Error generating image: {e}")
            if attempt < max_retries:
                time.sleep(2)  # Optional: delay before retrying
            else:
                print("Max retries reached. Failed to generate image.")
                return None

def provide_AI_image(title):
    client = OpenAI(api_key=api_key2)

    # Construct a prompt for image generation
    prompt = f"Inform me whenever a prompt contains copyright material, and generate an alternative that is close to the original aesthetic and subjective material, but without any copyright material. Create retropixel images based on the following super smash brothers melee clip title: '{title}' "

    try:
        response = client.images.generate(
            model="dall-e-3",  # Specify the latest model for better quality
            prompt=prompt,
            n=1,  # Generate only one image
            size="1792x1024"  # Specify the size
        )

        # Extract the image URL
        image_url = response.data[0].url

        # Define the output file path
        image_filename = f"{title.replace(' ', '_').replace('#', '')}.png"
        image_path = os.path.join(config.SHORTS_IMAGES_PATH, image_filename)

        # Download and save the image
        import requests
        img_data = requests.get(image_url).content
        with open(image_path, "wb") as img_file:
            img_file.write(img_data)

        print(f"Image saved successfully: {image_path}")
        return image_path

    except Exception as e:
        print(f"Error generating image: {e}")
        return None


# Load previous titles from file if it exists
def load_used_titles():
    if os.path.exists(config.TITLE_HISTORY_FILE):
        with open(config.TITLE_HISTORY_FILE, "r", encoding="utf-8") as f:
            return [line.strip() for line in f.readlines()]
    return []

# Save new title to history
def save_used_title(title):
    with open(config.TITLE_HISTORY_FILE, "a", encoding="utf-8") as f:
        f.write(title + "\n")

# Check similarity between two titles
def is_too_similar(new_title, used_titles, threshold=0.75):
    for old_title in used_titles:
        similarity = SequenceMatcher(None, new_title.lower(), old_title.lower()).ratio()
        if similarity >= threshold:
            return True  # Too similar
    return False



API_KEY_FILE = config.OPEN_AI_API_KEY
api_key2 = load_openai_key()
# Verify if key was loaded
if api_key2:
    print("OpenAI API key loaded successfully.")
else:
    print("Failed to load OpenAI API key.")

#when writing thumbnail pairing, need to have an option for none and to handle correctly during youtube upload
#need to check upload youtube function to allow passing of a thumbnail
#need to update provide image function to include short descripition of the venue its located at or other unique information
#need to have seperate title history for compilations


